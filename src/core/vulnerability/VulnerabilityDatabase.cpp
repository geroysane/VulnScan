#include "VulnerabilityDatabase.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QThread>
#include <QMutexLocker>
#include <QVariant>
#include <QDebug>
#include <QFile>
#include <cstdio>

VulnerabilityDatabase::VulnerabilityDatabase(const QString& databasePath, int maxConnections)
    : m_databasePath(databasePath)
    , m_maxConnections(maxConnections)
    , m_initialized(false)
    , m_connectionCounter(0)
{
    // Generate unique instance ID for connection naming
    // This ensures each VulnerabilityDatabase instance has its own connection pool
    m_instanceId = QString::number(reinterpret_cast<quintptr>(this), 16);
}

VulnerabilityDatabase::~VulnerabilityDatabase()
{
    // Close all database connections created by THIS instance only
    QMutexLocker locker(&m_mutex);

    // Remove only connections created by this instance
    QString prefix = "vuln_db_" + m_instanceId + "_";
    QStringList connections = QSqlDatabase::connectionNames();
    for (const QString& name : connections) {
        if (name.startsWith(prefix)) {
            // IMPORTANT: Must close connection before removing it
            {
                QSqlDatabase db = QSqlDatabase::database(name, false);
                if (db.isValid() && db.isOpen()) {
                    db.close();
                }
            }
            // Now remove the connection (QSqlDatabase object must be out of scope)
            QSqlDatabase::removeDatabase(name);
        }
    }
}

bool VulnerabilityDatabase::initialize()
{
    QMutexLocker locker(&m_mutex);

    QString connName = getConnection();

    if (connName.isEmpty()) {
        // getConnection() already set m_lastError
        return false;
    }

    QSqlDatabase db = QSqlDatabase::database(connName);

    if (!db.isValid()) {
        m_lastError = "Invalid database connection";
        return false;
    }

    if (!db.isOpen()) {
        m_lastError = "Database is not open";
        return false;
    }

    // Create CVE entries table
    QString createTableSql = R"(
        CREATE TABLE IF NOT EXISTS cve_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cve_id TEXT NOT NULL UNIQUE,
            description TEXT NOT NULL,
            severity TEXT NOT NULL,
            cvss_score REAL NOT NULL DEFAULT 0.0,
            affected_service TEXT NOT NULL,
            affected_versions TEXT NOT NULL,
            published_date TEXT,
            refs TEXT,
            cwe_id TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    )";

    QSqlQuery query(db);
    if (!query.exec(createTableSql)) {
        m_lastError = "Failed to create cve_entries table: " + query.lastError().text();
        return false;
    }

    // Create indexes for performance
    query.exec("CREATE INDEX IF NOT EXISTS idx_cve_id ON cve_entries(cve_id)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_service ON cve_entries(affected_service)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_severity ON cve_entries(severity)");

    m_initialized = true;
    m_lastError.clear();
    return true;
}

bool VulnerabilityDatabase::insertCve(CveEntry& entry)
{
    QMutexLocker locker(&m_mutex);

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QString sql = R"(
        INSERT INTO cve_entries (cve_id, description, severity, cvss_score,
                                 affected_service, affected_versions, published_date,
                                 refs, cwe_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    )";

    QSqlQuery query(db);
    query.prepare(sql);
    query.addBindValue(entry.cveId);
    query.addBindValue(entry.description);
    query.addBindValue(entry.severity);
    query.addBindValue(entry.cvssScore);
    query.addBindValue(entry.affectedService);
    query.addBindValue(entry.affectedVersions);
    query.addBindValue(entry.publishedDate);
    query.addBindValue(entry.references);
    query.addBindValue(entry.cweId);

    if (!query.exec()) {
        m_lastError = "Failed to insert CVE: " + query.lastError().text();
        return false;
    }

    entry.id = query.lastInsertId().toInt();
    m_lastError.clear();
    return true;
}

bool VulnerabilityDatabase::updateCve(const CveEntry& entry)
{
    QMutexLocker locker(&m_mutex);

    if (entry.id <= 0) {
        m_lastError = "Invalid CVE entry ID";
        return false;
    }

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QString sql = R"(
        UPDATE cve_entries
        SET cve_id = ?, description = ?, severity = ?, cvss_score = ?,
            affected_service = ?, affected_versions = ?, published_date = ?,
            refs = ?, cwe_id = ?, updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
    )";

    QSqlQuery query(db);
    query.prepare(sql);
    query.addBindValue(entry.cveId);
    query.addBindValue(entry.description);
    query.addBindValue(entry.severity);
    query.addBindValue(entry.cvssScore);
    query.addBindValue(entry.affectedService);
    query.addBindValue(entry.affectedVersions);
    query.addBindValue(entry.publishedDate);
    query.addBindValue(entry.references);
    query.addBindValue(entry.cweId);
    query.addBindValue(entry.id);

    if (!query.exec()) {
        m_lastError = "Failed to update CVE: " + query.lastError().text();
        return false;
    }

    if (query.numRowsAffected() == 0) {
        m_lastError = "CVE entry not found";
        return false;
    }

    m_lastError.clear();
    return true;
}

bool VulnerabilityDatabase::deleteCve(int id)
{
    QMutexLocker locker(&m_mutex);

    if (id <= 0) {
        m_lastError = "Invalid CVE entry ID";
        return false;
    }

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QSqlQuery query(db);
    query.prepare("DELETE FROM cve_entries WHERE id = ?");
    query.addBindValue(id);

    if (!query.exec()) {
        m_lastError = "Failed to delete CVE: " + query.lastError().text();
        return false;
    }

    if (query.numRowsAffected() == 0) {
        m_lastError = "CVE entry not found";
        return false;
    }

    m_lastError.clear();
    return true;
}

bool VulnerabilityDatabase::findByCveId(const QString& cveId, CveEntry& entry) const
{
    QMutexLocker locker(&m_mutex);

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QSqlQuery query(db);
    query.prepare("SELECT * FROM cve_entries WHERE cve_id = ?");
    query.addBindValue(cveId);

    if (!query.exec()) {
        m_lastError = "Failed to query CVE: " + query.lastError().text();
        return false;
    }

    if (!query.next()) {
        m_lastError = "CVE not found";
        return false;
    }

    entry.id = query.value("id").toInt();
    entry.cveId = query.value("cve_id").toString();
    entry.description = query.value("description").toString();
    entry.severity = query.value("severity").toString();
    entry.cvssScore = query.value("cvss_score").toFloat();
    entry.affectedService = query.value("affected_service").toString();
    entry.affectedVersions = query.value("affected_versions").toString();
    entry.publishedDate = query.value("published_date").toString();
    entry.references = query.value("refs").toString();
    entry.cweId = query.value("cwe_id").toString();

    m_lastError.clear();
    return true;
}

QVector<CveEntry> VulnerabilityDatabase::findByService(const QString& serviceName) const
{
    QMutexLocker locker(&m_mutex);

    QVector<CveEntry> results;

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QSqlQuery query(db);
    query.prepare("SELECT * FROM cve_entries WHERE LOWER(affected_service) = LOWER(?) ORDER BY cvss_score DESC");
    query.addBindValue(serviceName);

    if (!query.exec()) {
        m_lastError = "Failed to query CVEs: " + query.lastError().text();
        return results;
    }

    while (query.next()) {
        CveEntry entry;
        entry.id = query.value("id").toInt();
        entry.cveId = query.value("cve_id").toString();
        entry.description = query.value("description").toString();
        entry.severity = query.value("severity").toString();
        entry.cvssScore = query.value("cvss_score").toFloat();
        entry.affectedService = query.value("affected_service").toString();
        entry.affectedVersions = query.value("affected_versions").toString();
        entry.publishedDate = query.value("published_date").toString();
        entry.references = query.value("refs").toString();
        entry.cweId = query.value("cwe_id").toString();
        results.append(entry);
    }

    m_lastError.clear();
    return results;
}

QVector<CveEntry> VulnerabilityDatabase::findByServiceAndVersion(const QString& serviceName, const QString& version) const
{
    // NOTE: Do NOT lock mutex here - findByService() already locks it
    // Locking here would cause a deadlock (non-recursive mutex)

    QVector<CveEntry> allServiceCves = findByService(serviceName);
    QVector<CveEntry> matchingCves;

    for (const CveEntry& cve : allServiceCves) {
        if (matchesVersionPattern(version, cve.affectedVersions)) {
            matchingCves.append(cve);
        }
    }

    return matchingCves;
}

QVector<CveEntry> VulnerabilityDatabase::getAllCves() const
{
    QMutexLocker locker(&m_mutex);

    QVector<CveEntry> results;

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QSqlQuery query(db);
    if (!query.exec("SELECT * FROM cve_entries ORDER BY cvss_score DESC")) {
        m_lastError = "Failed to query all CVEs: " + query.lastError().text();
        return results;
    }

    while (query.next()) {
        CveEntry entry;
        entry.id = query.value("id").toInt();
        entry.cveId = query.value("cve_id").toString();
        entry.description = query.value("description").toString();
        entry.severity = query.value("severity").toString();
        entry.cvssScore = query.value("cvss_score").toFloat();
        entry.affectedService = query.value("affected_service").toString();
        entry.affectedVersions = query.value("affected_versions").toString();
        entry.publishedDate = query.value("published_date").toString();
        entry.references = query.value("refs").toString();
        entry.cweId = query.value("cwe_id").toString();
        results.append(entry);
    }

    m_lastError.clear();
    return results;
}

int VulnerabilityDatabase::getCveCount() const
{
    QMutexLocker locker(&m_mutex);

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QSqlQuery query(db);
    if (!query.exec("SELECT COUNT(*) FROM cve_entries")) {
        m_lastError = "Failed to count CVEs: " + query.lastError().text();
        return 0;
    }

    if (query.next()) {
        return query.value(0).toInt();
    }

    return 0;
}

bool VulnerabilityDatabase::clearAllCves()
{
    QMutexLocker locker(&m_mutex);

    QString connName = getConnection();
    QSqlDatabase db = QSqlDatabase::database(connName);

    QSqlQuery query(db);
    if (!query.exec("DELETE FROM cve_entries")) {
        m_lastError = "Failed to clear CVEs: " + query.lastError().text();
        return false;
    }

    m_lastError.clear();
    return true;
}

QString VulnerabilityDatabase::getConnection() const
{
    // Get instance-specific and thread-specific connection name
    // Format: vuln_db_{instanceId}_{threadId}
    QString threadId = QString::number(reinterpret_cast<quintptr>(QThread::currentThreadId()));
    QString connName = "vuln_db_" + m_instanceId + "_" + threadId;

    // Check if connection exists for this thread
    if (QSqlDatabase::contains(connName)) {
        QSqlDatabase existingDb = QSqlDatabase::database(connName);

        // Check if existing connection is still valid and points to the same database
        if (existingDb.isValid() && existingDb.databaseName() == m_databasePath) {
            // IMPORTANT: Check if database file still exists
            // Tests may delete the file between runs
            if (!QFile::exists(m_databasePath)) {
                // Database file was deleted - close and remove connection
                if (existingDb.isOpen()) {
                    existingDb.close();
                }
                QSqlDatabase::removeDatabase(connName);
                // Will create new connection below
            } else if (!existingDb.isOpen()) {
                // Connection exists but closed - try to reopen
                if (!existingDb.open()) {
                    // Failed to reopen - remove and recreate
                    QSqlDatabase::removeDatabase(connName);
                } else {
                    return connName;
                }
            } else {
                // Connection is open and file exists - reuse it
                return connName;
            }
        } else {
            // Connection points to different database path - remove it
            if (existingDb.isOpen()) {
                existingDb.close();
            }
            QSqlDatabase::removeDatabase(connName);
        }
    }

    // Create new connection for this thread
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", connName);

    if (!db.isValid()) {
        m_lastError = "QSQLITE driver not available";
        return QString();
    }

    db.setDatabaseName(m_databasePath);

    if (!db.open()) {
        m_lastError = "Failed to open database '" + m_databasePath + "': " + db.lastError().text();
        return QString();
    }

    // NOTE: WAL mode disabled for now - causes issues with test cleanup
    // when database files are deleted while WAL files remain open
    // Enable WAL mode for better concurrent access
    // QSqlQuery query(db);
    // query.exec("PRAGMA journal_mode=WAL");
    // query.exec("PRAGMA synchronous=NORMAL");

    return connName;
}

bool VulnerabilityDatabase::matchesVersionPattern(const QString& version, const QString& pattern) const
{
    if (pattern.isEmpty() || version.isEmpty()) {
        return false;
    }

    // Handle wildcard pattern (e.g., "1.*" matches "1.0", "1.2.3", etc.)
    if (pattern.contains('*')) {
        QString prefix = pattern.left(pattern.indexOf('*'));
        return version.startsWith(prefix);
    }

    // Handle range pattern (e.g., "2.0-2.5")
    if (pattern.contains('-')) {
        QStringList parts = pattern.split('-');
        if (parts.size() == 2) {
            QString minVersion = parts[0].trimmed();
            QString maxVersion = parts[1].trimmed();

            int cmpMin = compareVersions(version, minVersion);
            int cmpMax = compareVersions(version, maxVersion);

            // Version is in range if: version >= minVersion && version <= maxVersion
            return (cmpMin >= 0 && cmpMax <= 0);
        }
    }

    // Handle exact match
    return (compareVersions(version, pattern) == 0);
}

int VulnerabilityDatabase::compareVersions(const QString& v1, const QString& v2) const
{
    QStringList parts1 = v1.split('.');
    QStringList parts2 = v2.split('.');

    int maxLen = qMax(parts1.size(), parts2.size());

    for (int i = 0; i < maxLen; ++i) {
        int num1 = (i < parts1.size()) ? parts1[i].toInt() : 0;
        int num2 = (i < parts2.size()) ? parts2[i].toInt() : 0;

        if (num1 < num2) return -1;
        if (num1 > num2) return 1;
    }

    return 0; // Versions are equal
}
