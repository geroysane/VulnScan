#include "VulnerabilityScanner.h"
#include "VulnerabilityWorker.h"
#include <QMutexLocker>

VulnerabilityScanner::VulnerabilityScanner(VulnerabilityDatabase& database, QObject* parent)
    : QObject(parent)
    , m_database(database)
    , m_matcher(database)
    , m_threadPool(new QThreadPool(this))
    , m_totalServices(0)
    , m_completedServices(0)
    , m_isScanning(false)
    , m_cancelled(false)
{
    // Use optimal thread count for CPU
    m_threadPool->setMaxThreadCount(QThread::idealThreadCount());
}

VulnerabilityScanner::~VulnerabilityScanner()
{
    // Wait for all active workers to complete
    m_threadPool->waitForDone();
}

void VulnerabilityScanner::assessVulnerabilities(const ScanResult& scanResult)
{
    QMutexLocker locker(&m_mutex);

    if (m_isScanning) {
        emit error("Vulnerability assessment already in progress");
        return;
    }

    // Reset state
    m_results.clear();
    m_totalServices = 0;
    m_completedServices = 0;
    m_isScanning = true;
    m_cancelled = false;

    // Count total services to assess (only open ports with detected services)
    for (const PortResult& portResult : scanResult.ports) {
        if (portResult.state == "open" && !portResult.service.isEmpty()) {
            m_totalServices++;
        }
    }

    if (m_totalServices == 0) {
        m_isScanning = false;
        emit finished(m_results);
        return;
    }

    locker.unlock();

    // Create and queue workers for each service
    for (const PortResult& portResult : scanResult.ports) {
        if (portResult.state == "open" && !portResult.service.isEmpty()) {
            VulnerabilityWorker* worker = new VulnerabilityWorker(
                this,
                scanResult.targetHost,
                portResult.port,
                portResult.service,
                portResult.version
            );
            m_threadPool->start(worker);
        }
    }
}

void VulnerabilityScanner::cancel()
{
    QMutexLocker locker(&m_mutex);
    m_cancelled = true;

    // Try to cancel pending workers
    m_threadPool->clear();
}

bool VulnerabilityScanner::isScanning() const
{
    QMutexLocker locker(&m_mutex);
    return m_isScanning;
}

QVector<VulnerabilityResult> VulnerabilityScanner::getResults() const
{
    QMutexLocker locker(&m_mutex);
    return m_results;
}

void VulnerabilityScanner::addResult(const VulnerabilityResult& result)
{
    QMutexLocker locker(&m_mutex);

    if (m_cancelled) {
        return;
    }

    // Add result to collection
    m_results.append(result);

    // Emit signal if vulnerabilities found
    if (result.vulnerabilityCount > 0) {
        emit vulnerabilityFound(result);
    }
}

void VulnerabilityScanner::reportProgress()
{
    QMutexLocker locker(&m_mutex);

    if (m_cancelled) {
        return;
    }

    m_completedServices++;

    emit progress(m_completedServices, m_totalServices);

    // Check if all services assessed
    if (m_completedServices >= m_totalServices) {
        locker.unlock();
        onAssessmentComplete();
    }
}

void VulnerabilityScanner::onAssessmentComplete()
{
    // Wait for all workers to finish
    m_threadPool->waitForDone();

    QMutexLocker locker(&m_mutex);
    m_isScanning = false;

    emit finished(m_results);
}
