#include "HttpVulnChecker.h"
#include <QNetworkRequest>
#include <QTimer>
#include <QStringList>
#include <QUrl>
#include <QRegularExpression>

HttpVulnChecker::HttpVulnChecker(QObject *parent)
    : ServiceVulnChecker(parent)
{
    m_networkManager = new QNetworkAccessManager(this);
}

HttpVulnChecker::~HttpVulnChecker()
{
}

bool HttpVulnChecker::canHandle(const QString &serviceName) const
{
    QString lower = serviceName.toLower();
    return lower.contains("http") || lower.contains("https") ||
           lower.contains("web") || lower.contains("apache") ||
           lower.contains("nginx") || lower.contains("iis");
}

QString HttpVulnChecker::name() const
{
    return "HTTP Vulnerability Checker";
}

QString HttpVulnChecker::description() const
{
    return "Checks for missing security headers, dangerous HTTP methods, "
           "common vulnerable paths, and server information disclosure.";
}

QList<Vulnerability> HttpVulnChecker::checkVulnerabilities(const QString &host, const PortResult &port)
{
    QList<Vulnerability> vulnerabilities;

    // Construct base URL
    QString protocol = (port.port == 443 || port.service.toLower().contains("https")) ? "https" : "http";
    QString url = QString("%1://%2:%3").arg(protocol, host).arg(port.port);
    QString serviceName = QString("%1 %2").arg(port.service, port.version).trimmed();

    // Perform various checks
    vulnerabilities.append(checkSecurityHeaders(url, serviceName));
    vulnerabilities.append(checkDangerousMethods(url, serviceName));
    vulnerabilities.append(checkCommonPaths(url, serviceName));
    vulnerabilities.append(checkInformationDisclosure(url, serviceName));

    emit checkComplete(vulnerabilities);
    return vulnerabilities;
}

QList<Vulnerability> HttpVulnChecker::checkSecurityHeaders(const QString &url, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    QNetworkReply *reply = performRequest(url, "GET");
    if (!reply) {
        return vulnerabilities;
    }

    // Check for missing HSTS header
    if (url.startsWith("https://") && isMissingOrWeak(reply, "Strict-Transport-Security")) {
        Vulnerability vuln = createVulnerability(
            "HTTP-MISSING-HSTS",
            "Missing HTTP Strict Transport Security (HSTS) header. "
            "This allows potential downgrade attacks and man-in-the-middle attacks.",
            "Medium",
            5.3f,
            serviceName,
            "Add 'Strict-Transport-Security: max-age=31536000; includeSubDomains' header"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Check for missing X-Frame-Options
    if (isMissingOrWeak(reply, "X-Frame-Options")) {
        Vulnerability vuln = createVulnerability(
            "HTTP-MISSING-X-FRAME-OPTIONS",
            "Missing X-Frame-Options header. This makes the site vulnerable to clickjacking attacks.",
            "Medium",
            4.3f,
            serviceName,
            "Add 'X-Frame-Options: DENY' or 'X-Frame-Options: SAMEORIGIN' header"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Check for missing X-Content-Type-Options
    if (isMissingOrWeak(reply, "X-Content-Type-Options")) {
        Vulnerability vuln = createVulnerability(
            "HTTP-MISSING-X-CONTENT-TYPE",
            "Missing X-Content-Type-Options header. This allows MIME type sniffing attacks.",
            "Low",
            3.7f,
            serviceName,
            "Add 'X-Content-Type-Options: nosniff' header"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Check for missing Content-Security-Policy
    if (isMissingOrWeak(reply, "Content-Security-Policy")) {
        Vulnerability vuln = createVulnerability(
            "HTTP-MISSING-CSP",
            "Missing Content-Security-Policy header. This increases risk of XSS attacks.",
            "Medium",
            5.0f,
            serviceName,
            "Add a restrictive Content-Security-Policy header"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Check for missing X-XSS-Protection
    if (isMissingOrWeak(reply, "X-XSS-Protection")) {
        Vulnerability vuln = createVulnerability(
            "HTTP-MISSING-XSS-PROTECTION",
            "Missing X-XSS-Protection header. Consider enabling browser XSS protection.",
            "Low",
            3.1f,
            serviceName,
            "Add 'X-XSS-Protection: 1; mode=block' header"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    reply->deleteLater();
    return vulnerabilities;
}

QList<Vulnerability> HttpVulnChecker::checkDangerousMethods(const QString &url, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Check OPTIONS to see what methods are allowed
    QNetworkReply *reply = performRequest(url, "OPTIONS");
    if (!reply) {
        return vulnerabilities;
    }

    QString allowHeader = reply->rawHeader("Allow");
    QStringList allowedMethods = allowHeader.split(",", Qt::SkipEmptyParts);

    // Check for dangerous methods
    QStringList dangerousMethods = {"TRACE", "PUT", "DELETE", "CONNECT"};
    for (const QString &method : dangerousMethods) {
        if (allowedMethods.contains(method, Qt::CaseInsensitive)) {
            QString severity = (method == "TRACE") ? "Medium" : "High";
            float cvss = (method == "TRACE") ? 4.3f : 6.5f;

            Vulnerability vuln = createVulnerability(
                QString("HTTP-DANGEROUS-METHOD-%1").arg(method),
                QString("HTTP %1 method is enabled. This can be exploited for security attacks.").arg(method),
                severity,
                cvss,
                serviceName,
                QString("Disable %1 method in web server configuration").arg(method)
            );
            vulnerabilities.append(vuln);
            emit vulnerabilityDetected(vuln);
        }
    }

    reply->deleteLater();
    return vulnerabilities;
}

QList<Vulnerability> HttpVulnChecker::checkCommonPaths(const QString &url, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // List of common vulnerable/sensitive paths
    QStringList paths = {
        "/.git/config",
        "/.env",
        "/.DS_Store",
        "/admin",
        "/phpmyadmin",
        "/config.php",
        "/wp-config.php",
        "/.svn/entries",
        "/backup.sql",
        "/server-status"
    };

    for (const QString &path : paths) {
        QNetworkReply *reply = performRequest(url + path, "GET");
        if (reply && reply->error() == QNetworkReply::NoError) {
            int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();

            // Check if path is accessible (200-299 status codes)
            if (statusCode >= 200 && statusCode < 300) {
                QString pathId = QString(path).replace("/", "-").replace(".", "");
                Vulnerability vuln = createVulnerability(
                    QString("HTTP-EXPOSED-PATH-%1").arg(pathId),
                    QString("Sensitive path '%1' is publicly accessible. This may expose confidential information.").arg(path),
                    "High",
                    7.5f,
                    serviceName,
                    QString("Restrict access to '%1' or remove it from public web directory").arg(path)
                );
                vulnerabilities.append(vuln);
                emit vulnerabilityDetected(vuln);
            }
        }

        if (reply) {
            reply->deleteLater();
        }
    }

    return vulnerabilities;
}

QList<Vulnerability> HttpVulnChecker::checkInformationDisclosure(const QString &url, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    QNetworkReply *reply = performRequest(url, "GET");
    if (!reply) {
        return vulnerabilities;
    }

    // Check for Server header disclosure
    QString serverHeader = reply->rawHeader("Server");
    if (!serverHeader.isEmpty() && !serverHeader.contains("Unknown", Qt::CaseInsensitive)) {
        // Check if it's a detailed server version (contains version numbers)
        if (serverHeader.contains(QRegularExpression("[0-9]+\\.[0-9]+"))) {
            Vulnerability vuln = createVulnerability(
                "HTTP-SERVER-DISCLOSURE",
                QString("Server header discloses detailed version information: '%1'. "
                       "This helps attackers identify known vulnerabilities.").arg(serverHeader),
                "Low",
                2.7f,
                serviceName,
                "Configure web server to hide detailed version information in Server header"
            );
            vulnerabilities.append(vuln);
            emit vulnerabilityDetected(vuln);
        }
    }

    // Check for X-Powered-By header
    QString poweredByHeader = reply->rawHeader("X-Powered-By");
    if (!poweredByHeader.isEmpty()) {
        Vulnerability vuln = createVulnerability(
            "HTTP-POWERED-BY-DISCLOSURE",
            QString("X-Powered-By header discloses technology stack: '%1'. "
                   "This provides attackers with information about the underlying technology.").arg(poweredByHeader),
            "Low",
            2.5f,
            serviceName,
            "Remove X-Powered-By header from server configuration"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    reply->deleteLater();
    return vulnerabilities;
}

QNetworkReply* HttpVulnChecker::performRequest(const QString &url, const QString &method)
{
    QUrl qurl(url);
    QNetworkRequest request(qurl);
    request.setHeader(QNetworkRequest::UserAgentHeader, "VulnScan/1.0");

    QNetworkReply *reply = nullptr;

    if (method == "GET") {
        reply = m_networkManager->get(request);
    } else if (method == "HEAD") {
        reply = m_networkManager->head(request);
    } else if (method == "OPTIONS") {
        reply = m_networkManager->sendCustomRequest(request, "OPTIONS");
    } else {
        reply = m_networkManager->sendCustomRequest(request, method.toUtf8());
    }

    // Wait for reply with timeout
    QEventLoop loop;
    QTimer timer;
    timer.setSingleShot(true);

    connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);

    timer.start(m_timeout);
    loop.exec();

    // Check if request timed out
    if (!timer.isActive()) {
        reply->abort();
        emit errorOccurred(QString("Request to %1 timed out").arg(url));
        reply->deleteLater();
        return nullptr;
    }

    timer.stop();

    // Check for network errors (but don't fail - we still want headers)
    if (reply->error() != QNetworkReply::NoError &&
        reply->error() != QNetworkReply::ContentNotFoundError) {
        emit errorOccurred(QString("Network error: %1").arg(reply->errorString()));
    }

    return reply;
}

bool HttpVulnChecker::isMissingOrWeak(const QNetworkReply *reply, const QString &headerName, const QString &requiredValue) const
{
    if (!reply) {
        return true;
    }

    QString headerValue = reply->rawHeader(headerName.toUtf8());

    if (headerValue.isEmpty()) {
        return true;
    }

    if (!requiredValue.isEmpty() && !headerValue.contains(requiredValue, Qt::CaseInsensitive)) {
        return true;
    }

    return false;
}
