#include "CveSeeder.h"
#include "VulnerabilityDatabase.h"
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QTextStream>

CveSeeder::CveSeeder()
{
}

CveSeeder::~CveSeeder()
{
}

int CveSeeder::seedWithSampleData(VulnerabilityDatabase* db)
{
    if (!db) {
        return 0;
    }

    QList<CveEntry> sampleData = getSampleCveData();
    int count = 0;

    for (const CveEntry& entry : sampleData) {
        if (insertCveEntry(db, entry)) {
            count++;
        }
    }

    return count;
}

int CveSeeder::seedFromJsonFile(VulnerabilityDatabase* db, const QString& jsonFilePath)
{
    if (!db) {
        return 0;
    }

    QFile file(jsonFilePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return 0;
    }

    QByteArray jsonData = file.readAll();
    file.close();

    QJsonDocument doc = QJsonDocument::fromJson(jsonData);
    if (!doc.isArray() && !doc.isObject()) {
        return 0;
    }

    int count = 0;

    // Handle both array of CVEs and object with CVEs array
    QJsonArray cveArray;
    if (doc.isArray()) {
        cveArray = doc.array();
    } else if (doc.isObject()) {
        QJsonObject root = doc.object();
        if (root.contains("cves")) {
            cveArray = root["cves"].toArray();
        }
    }

    for (const QJsonValue& value : cveArray) {
        if (value.isObject()) {
            CveEntry entry = parseJsonCve(value.toObject());
            if (insertCveEntry(db, entry)) {
                count++;
            }
        }
    }

    return count;
}

int CveSeeder::seedFromCsvFile(VulnerabilityDatabase* db, const QString& csvFilePath)
{
    if (!db) {
        return 0;
    }

    QFile file(csvFilePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return 0;
    }

    QTextStream in(&file);
    int count = 0;
    bool headerSkipped = false;

    while (!in.atEnd()) {
        QString line = in.readLine().trimmed();

        // Skip header line
        if (!headerSkipped) {
            headerSkipped = true;
            continue;
        }

        if (line.isEmpty()) {
            continue;
        }

        CveEntry entry = parseCsvLine(line);
        if (!entry.cveId.isEmpty() && insertCveEntry(db, entry)) {
            count++;
        }
    }

    file.close();
    return count;
}

QList<CveEntry> CveSeeder::getSampleCveData()
{
    QList<CveEntry> sampleData;

    // Apache HTTP Server CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2021-44228";
        entry.description = "Apache Log4j2 2.0-beta9 through 2.15.0 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled.";
        entry.severity = "Critical";
        entry.cvssScore = 10.0f;
        entry.affectedService = "Apache";
        entry.affectedVersions = "2.0-beta9 to 2.15.0";
        entry.publishedDate = "2021-12-10";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2021-44228";
        entry.cweId = "CWE-502";
        sampleData.append(entry);
    }

    {
        CveEntry entry;
        entry.cveId = "CVE-2021-41773";
        entry.description = "A flaw was found in a change made to path normalization in Apache HTTP Server 2.4.49. An attacker could use a path traversal attack to map URLs to files outside the directories configured by Alias-like directives.";
        entry.severity = "High";
        entry.cvssScore = 7.5f;
        entry.affectedService = "Apache";
        entry.affectedVersions = "2.4.49";
        entry.publishedDate = "2021-10-05";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2021-41773";
        entry.cweId = "CWE-22";
        sampleData.append(entry);
    }

    // nginx CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2021-23017";
        entry.description = "A security issue in nginx resolver was identified, which might allow an attacker who is able to forge UDP packets from the DNS server to cause 1-byte memory overwrite, resulting in worker process crash or potential other impact.";
        entry.severity = "High";
        entry.cvssScore = 8.1f;
        entry.affectedService = "nginx";
        entry.affectedVersions = "0.6.18-1.20.0";
        entry.publishedDate = "2021-06-01";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2021-23017";
        entry.cweId = "CWE-193";
        sampleData.append(entry);
    }

    // OpenSSH CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2020-15778";
        entry.description = "scp in OpenSSH through 8.3p1 allows command injection in the scp.c toremote function, as demonstrated by backtick characters in the destination argument.";
        entry.severity = "High";
        entry.cvssScore = 7.8f;
        entry.affectedService = "OpenSSH";
        entry.affectedVersions = "*-8.3";
        entry.publishedDate = "2020-07-24";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2020-15778";
        entry.cweId = "CWE-78";
        sampleData.append(entry);
    }

    {
        CveEntry entry;
        entry.cveId = "CVE-2016-10009";
        entry.description = "Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.";
        entry.severity = "High";
        entry.cvssScore = 7.5f;
        entry.affectedService = "OpenSSH";
        entry.affectedVersions = "*-7.3";
        entry.publishedDate = "2017-01-05";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2016-10009";
        entry.cweId = "CWE-426";
        sampleData.append(entry);
    }

    // vsftpd CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2015-1419";
        entry.description = "Unspecified vulnerability in vsftpd 3.0.2 and earlier allows remote attackers to bypass access restrictions via unknown vectors.";
        entry.severity = "Medium";
        entry.cvssScore = 5.3f;
        entry.affectedService = "vsftpd";
        entry.affectedVersions = "*-3.0.2";
        entry.publishedDate = "2015-02-06";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2015-1419";
        entry.cweId = "CWE-264";
        sampleData.append(entry);
    }

    // ProFTPD CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2015-3306";
        entry.description = "The mod_copy module in ProFTPD 1.3.5 allows remote attackers to read and write to arbitrary files via the site cpfr and site cpto commands.";
        entry.severity = "Critical";
        entry.cvssScore = 9.8f;
        entry.affectedService = "ProFTPD";
        entry.affectedVersions = "1.3.5";
        entry.publishedDate = "2015-04-30";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2015-3306";
        entry.cweId = "CWE-284";
        sampleData.append(entry);
    }

    // MySQL CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2021-2194";
        entry.description = "Vulnerability in the MySQL Server product of Oracle MySQL (component: InnoDB). Supported versions that are affected are 8.0.23 and prior. Easily exploitable vulnerability allows high privileged attacker with network access via multiple protocols to compromise MySQL Server.";
        entry.severity = "Medium";
        entry.cvssScore = 4.9f;
        entry.affectedService = "MySQL";
        entry.affectedVersions = "*-8.0.23";
        entry.publishedDate = "2021-04-22";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2021-2194";
        entry.cweId = "CWE-noinfo";
        sampleData.append(entry);
    }

    // PostgreSQL CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2021-32027";
        entry.description = "A flaw was found in postgresql in versions before 13.3, before 12.7, before 11.12, before 10.17 and before 9.6.22. While modifying certain SQL array values, missing bounds checks let authenticated database users write arbitrary bytes to a wide area of server memory.";
        entry.severity = "High";
        entry.cvssScore = 8.8f;
        entry.affectedService = "PostgreSQL";
        entry.affectedVersions = "*-13.2";
        entry.publishedDate = "2021-06-01";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2021-32027";
        entry.cweId = "CWE-787";
        sampleData.append(entry);
    }

    // Microsoft IIS CVEs
    {
        CveEntry entry;
        entry.cveId = "CVE-2021-31207";
        entry.description = "Microsoft Exchange Server Remote Code Execution Vulnerability. This CVE ID is unique from CVE-2021-31206, CVE-2021-31209.";
        entry.severity = "Critical";
        entry.cvssScore = 9.1f;
        entry.affectedService = "IIS";
        entry.affectedVersions = "10.0";
        entry.publishedDate = "2021-05-11";
        entry.references = "https://nvd.nist.gov/vuln/detail/CVE-2021-31207";
        entry.cweId = "CWE-noinfo";
        sampleData.append(entry);
    }

    return sampleData;
}

bool CveSeeder::insertCveEntry(VulnerabilityDatabase* db, const CveEntry& entry)
{
    if (!db || entry.cveId.isEmpty()) {
        return false;
    }

    CveEntry mutableEntry = entry;
    return db->insertCve(mutableEntry);
}

CveEntry CveSeeder::parseJsonCve(const QJsonObject& jsonObj) const
{
    CveEntry entry;

    entry.cveId = jsonObj["cve_id"].toString();
    entry.description = jsonObj["description"].toString();
    entry.severity = jsonObj["severity"].toString();
    entry.cvssScore = jsonObj["cvss_score"].toDouble();
    entry.affectedService = jsonObj["affected_service"].toString();
    entry.affectedVersions = jsonObj["affected_versions"].toString();
    entry.publishedDate = jsonObj["published_date"].toString();
    entry.references = jsonObj["references"].toString();
    entry.cweId = jsonObj["cwe_id"].toString();

    return entry;
}

CveEntry CveSeeder::parseCsvLine(const QString& csvLine) const
{
    CveEntry entry;

    // Simple CSV parser (doesn't handle quoted fields with commas)
    QStringList fields = csvLine.split(',');

    if (fields.size() >= 9) {
        entry.cveId = fields[0].trimmed();
        entry.description = fields[1].trimmed();
        entry.severity = fields[2].trimmed();
        entry.cvssScore = fields[3].trimmed().toFloat();
        entry.affectedService = fields[4].trimmed();
        entry.affectedVersions = fields[5].trimmed();
        entry.publishedDate = fields[6].trimmed();
        entry.references = fields[7].trimmed();
        entry.cweId = fields[8].trimmed();
    }

    return entry;
}
