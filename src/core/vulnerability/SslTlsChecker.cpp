#include "SslTlsChecker.h"
#include <QTimer>
#include <QDateTime>
#include <QSslError>

SslTlsChecker::SslTlsChecker(QObject* parent)
    : QObject(parent)
    , m_socket(nullptr)
    , m_timer(nullptr)
    , m_isChecking(false)
    , m_targetPort(0)
{
}

SslTlsChecker::~SslTlsChecker()
{
    cleanup();
}

void SslTlsChecker::checkHost(const QString& host, int port, int timeout)
{
    if (m_isChecking) {
        emit error("SSL/TLS check already in progress");
        return;
    }

    // Initialize
    m_isChecking = true;
    m_targetHost = host;
    m_targetPort = port;
    m_result = SslTlsResult();
    m_result.host = host;
    m_result.port = port;

    // Create SSL socket
    m_socket = new QSslSocket(this);

    // Connect signals
    connect(m_socket, &QSslSocket::connected, this, &SslTlsChecker::onConnected);
    connect(m_socket, &QSslSocket::encrypted, this, &SslTlsChecker::onEncrypted);
    connect(m_socket, QOverload<const QList<QSslError>&>::of(&QSslSocket::sslErrors),
            this, &SslTlsChecker::onSslErrors);
    connect(m_socket, &QSslSocket::errorOccurred, this, &SslTlsChecker::onSocketError);

    // Setup timeout
    m_timer = new QTimer(this);
    m_timer->setSingleShot(true);
    connect(m_timer, &QTimer::timeout, this, &SslTlsChecker::onTimeout);
    m_timer->start(timeout);

    // Start connection
    m_socket->connectToHostEncrypted(host, port);
}

void SslTlsChecker::cancel()
{
    if (m_isChecking) {
        cleanup();
        m_isChecking = false;
    }
}

bool SslTlsChecker::isChecking() const
{
    return m_isChecking;
}

SslTlsResult SslTlsChecker::getLastResult() const
{
    return m_result;
}

void SslTlsChecker::onConnected()
{
    // Connection established, waiting for encryption
}

void SslTlsChecker::onEncrypted()
{
    // Stop timeout timer
    if (m_timer) {
        m_timer->stop();
    }

    m_result.sslSupported = true;

    // Analyze SSL/TLS configuration
    analyzeProtocol();
    analyzeCiphers();
    analyzeCertificate();

    // Finalize and emit result
    finalizeAnalysis();
}

void SslTlsChecker::onSslErrors(const QList<QSslError>& errors)
{
    // Collect SSL errors but continue to get certificate info
    QString errorMsg;
    for (const QSslError& error : errors) {
        if (!errorMsg.isEmpty()) {
            errorMsg += "; ";
        }
        errorMsg += error.errorString();
    }

    m_result.certificateError = errorMsg;
    m_result.certificateValid = false;

    // Ignore errors to complete handshake and get certificate
    m_socket->ignoreSslErrors();
}

void SslTlsChecker::onSocketError(QAbstractSocket::SocketError error)
{
    Q_UNUSED(error);

    m_result.sslSupported = false;
    QString errorMsg = m_socket ? m_socket->errorString() : "Unknown socket error";

    finalizeAnalysis();
}

void SslTlsChecker::onTimeout()
{
    m_result.sslSupported = false;
    emit error("SSL/TLS check timeout for " + m_targetHost);
    finalizeAnalysis();
}

void SslTlsChecker::analyzeProtocol()
{
    if (!m_socket) {
        return;
    }

    QSslConfiguration sslConfig = m_socket->sslConfiguration();
    QSsl::SslProtocol protocol = sslConfig.protocol();

    // Map protocol to string
    QString protocolStr;
    switch (protocol) {
        case QSsl::TlsV1_0:
            protocolStr = "TLS 1.0";
            break;
        case QSsl::TlsV1_1:
            protocolStr = "TLS 1.1";
            break;
        case QSsl::TlsV1_2:
            protocolStr = "TLS 1.2";
            break;
        case QSsl::TlsV1_3:
            protocolStr = "TLS 1.3";
            break;
        default:
            protocolStr = "Unknown";
            break;
    }

    m_result.protocol = protocolStr;
    m_result.supportedProtocols.append(protocolStr);

    // Check for deprecated protocols
    if (isDeprecatedProtocol(protocol)) {
        Vulnerability vuln;
        vuln.cveId = "SSL-TLS-DEPRECATED-PROTOCOL";
        vuln.severity = "CRITICAL";
        vuln.description = QString("Deprecated SSL/TLS Protocol: Server supports deprecated protocol: %1. "
                                   "This protocol has known vulnerabilities and should be disabled.")
                                   .arg(protocolStr);
        vuln.cvssScore = 9.0f;
        vuln.affectedService = QString("SSL/TLS (%1)").arg(protocolStr);
        vuln.recommendedAction = "Disable SSL 2.0, SSL 3.0, TLS 1.0, and TLS 1.1. Use TLS 1.2 or TLS 1.3.";

        m_result.vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }
}

void SslTlsChecker::analyzeCiphers()
{
    if (!m_socket) {
        return;
    }

    QSslConfiguration sslConfig = m_socket->sslConfiguration();
    QSslCipher sessionCipher = sslConfig.sessionCipher();

    if (!sessionCipher.isNull()) {
        m_result.ciphers.append(sessionCipher);

        // Check for weak ciphers
        if (isWeakCipher(sessionCipher)) {
            Vulnerability vuln;
            vuln.cveId = "SSL-TLS-WEAK-CIPHER";
            vuln.severity = "HIGH";
            vuln.description = QString("Weak Cipher Suite: Server uses weak cipher suite: %1. "
                                      "Weak ciphers can be vulnerable to cryptographic attacks.")
                                      .arg(sessionCipher.name());
            vuln.cvssScore = 7.5f;
            vuln.affectedService = QString("SSL/TLS (Cipher: %1)").arg(sessionCipher.name());
            vuln.recommendedAction = "Configure server to use strong cipher suites (e.g., AES-GCM, ChaCha20).";

            m_result.vulnerabilities.append(vuln);
            emit vulnerabilityDetected(vuln);
        }
    }
}

void SslTlsChecker::analyzeCertificate()
{
    if (!m_socket) {
        return;
    }

    QSslCertificate cert = m_socket->peerCertificate();
    if (cert.isNull()) {
        return;
    }

    m_result.certificate = cert;
    m_result.certificateChain = m_socket->peerCertificateChain();

    // Check certificate validity
    QDateTime now = QDateTime::currentDateTime();
    QDateTime expiryDate = cert.expiryDate();
    QDateTime effectiveDate = cert.effectiveDate();

    // Check if certificate is expired
    if (expiryDate < now) {
        Vulnerability vuln;
        vuln.cveId = "SSL-TLS-CERT-EXPIRED";
        vuln.severity = "CRITICAL";
        vuln.description = QString("Expired Certificate: SSL certificate expired on %1")
                                  .arg(expiryDate.toString(Qt::ISODate));
        vuln.cvssScore = 9.0f;
        vuln.affectedService = "SSL/TLS Certificate";
        vuln.recommendedAction = "Renew SSL certificate immediately.";

        m_result.vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }
    // Check if certificate is not yet valid
    else if (effectiveDate > now) {
        Vulnerability vuln;
        vuln.cveId = "SSL-TLS-CERT-NOT-YET-VALID";
        vuln.severity = "HIGH";
        vuln.description = QString("Certificate Not Yet Valid: SSL certificate not valid until %1")
                                  .arg(effectiveDate.toString(Qt::ISODate));
        vuln.cvssScore = 7.0f;
        vuln.affectedService = "SSL/TLS Certificate";
        vuln.recommendedAction = "Check system clock or replace certificate.";

        m_result.vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }
    // Check if certificate is expiring soon (within 30 days)
    else if (expiryDate.daysTo(now) <= 30) {
        Vulnerability vuln;
        vuln.cveId = "SSL-TLS-CERT-EXPIRING-SOON";
        vuln.severity = "MEDIUM";
        vuln.description = QString("Certificate Expiring Soon: SSL certificate expires on %1 (%2 days remaining)")
                                  .arg(expiryDate.toString(Qt::ISODate))
                                  .arg(now.daysTo(expiryDate));
        vuln.cvssScore = 5.0f;
        vuln.affectedService = "SSL/TLS Certificate";
        vuln.recommendedAction = "Renew SSL certificate before expiration.";

        m_result.vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Check for self-signed certificate
    if (cert.isSelfSigned()) {
        Vulnerability vuln;
        vuln.cveId = "SSL-TLS-CERT-SELF-SIGNED";
        vuln.severity = "MEDIUM";
        vuln.description = "Self-Signed Certificate: Server uses a self-signed SSL certificate. "
                          "This can be vulnerable to man-in-the-middle attacks.";
        vuln.cvssScore = 6.0f;
        vuln.affectedService = "SSL/TLS Certificate";
        vuln.recommendedAction = "Use a certificate from a trusted Certificate Authority (CA).";

        m_result.vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Mark certificate as valid if no errors
    if (m_result.certificateError.isEmpty()) {
        m_result.certificateValid = true;
    }
}

bool SslTlsChecker::isWeakCipher(const QSslCipher& cipher) const
{
    QString cipherName = cipher.name().toUpper();

    // Check for weak/deprecated algorithms
    QStringList weakPatterns = {
        "NULL", "EXPORT", "DES", "RC4", "MD5",
        "ANON", "ADH", "AECDH",
        "3DES" // Triple DES is considered weak
    };

    for (const QString& pattern : weakPatterns) {
        if (cipherName.contains(pattern)) {
            return true;
        }
    }

    // Check cipher strength
    if (cipher.usedBits() < 128) {
        return true;
    }

    return false;
}

bool SslTlsChecker::isDeprecatedProtocol(QSsl::SslProtocol protocol) const
{
    // TLS 1.0, TLS 1.1 are deprecated (SSLv2/SSLv3 no longer exist in Qt 6.9)
    return (protocol == QSsl::TlsV1_0 ||
            protocol == QSsl::TlsV1_1);
}

void SslTlsChecker::finalizeAnalysis()
{
    m_isChecking = false;
    emit finished(m_result);
    cleanup();
}

void SslTlsChecker::cleanup()
{
    if (m_timer) {
        m_timer->stop();
        m_timer->deleteLater();
        m_timer = nullptr;
    }

    if (m_socket) {
        m_socket->abort();
        m_socket->deleteLater();
        m_socket = nullptr;
    }
}
