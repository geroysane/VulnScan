#include "VulnerabilityMatcher.h"
#include <QRegularExpression>
#include <QStringList>

VulnerabilityMatcher::VulnerabilityMatcher(VulnerabilityDatabase& database)
    : m_database(database)
{
}

QVector<CveEntry> VulnerabilityMatcher::findVulnerabilities(const QString& serviceName, const QString& version) const
{
    // Normalize service name for better matching
    QString normalizedService = normalizeServiceName(serviceName);

    if (version.isEmpty()) {
        // No version info - return all vulnerabilities for this service
        return findVulnerabilitiesForService(normalizedService);
    }

    // Query database for service + version match
    return m_database.findByServiceAndVersion(normalizedService, version);
}

QVector<CveEntry> VulnerabilityMatcher::findVulnerabilitiesForService(const QString& serviceName) const
{
    QString normalizedService = normalizeServiceName(serviceName);
    return m_database.findByService(normalizedService);
}

QString VulnerabilityMatcher::normalizeServiceName(const QString& serviceName)
{
    if (serviceName.isEmpty()) {
        return QString();
    }

    QString normalized = serviceName.trimmed();

    // Remove common suffixes
    static const QStringList suffixes = {"-server", "-daemon", "_server", "_daemon"};
    for (const QString& suffix : suffixes) {
        if (normalized.endsWith(suffix, Qt::CaseInsensitive)) {
            normalized.chop(suffix.length());
            break;
        }
    }

    // Extract service name before version slash (e.g., "nginx/1.18.0" â†’ "nginx")
    int slashPos = normalized.indexOf('/');
    if (slashPos > 0) {
        normalized = normalized.left(slashPos);
    }

    // Common service name mappings
    QString lower = normalized.toLower();

    if (lower.contains("apache")) {
        return "Apache";
    } else if (lower.contains("nginx")) {
        return "nginx";
    } else if (lower.contains("openssh") || lower.contains("ssh")) {
        return "OpenSSH";
    } else if (lower.contains("mysql")) {
        return "MySQL";
    } else if (lower.contains("postgresql") || lower.contains("postgres")) {
        return "PostgreSQL";
    } else if (lower.contains("vsftpd") || lower == "ftp") {
        return "vsftpd";
    } else if (lower.contains("proftpd")) {
        return "ProFTPD";
    } else if (lower.contains("bind") || lower == "dns") {
        return "BIND";
    } else if (lower.contains("postfix")) {
        return "Postfix";
    } else if (lower.contains("sendmail")) {
        return "Sendmail";
    }

    // Return original if no mapping found (capitalize first letter)
    if (!normalized.isEmpty()) {
        normalized[0] = normalized[0].toUpper();
    }

    return normalized;
}

QString VulnerabilityMatcher::extractVersion(const QString& banner)
{
    if (banner.isEmpty()) {
        return QString();
    }

    // Pattern 1: Version after slash (e.g., "Apache/2.4.49", "nginx/1.18.0")
    QRegularExpression slashPattern(R"(/(\d+(?:\.\d+)*))");
    QRegularExpressionMatch slashMatch = slashPattern.match(banner);
    if (slashMatch.hasMatch()) {
        return slashMatch.captured(1);
    }

    // Pattern 2: Version after underscore (e.g., "OpenSSH_7.4")
    QRegularExpression underscorePattern(R"(_(\d+(?:\.\d+)*))");
    QRegularExpressionMatch underscoreMatch = underscorePattern.match(banner);
    if (underscoreMatch.hasMatch()) {
        return underscoreMatch.captured(1);
    }

    // Pattern 3: Version after space (e.g., "Apache 2.4.49")
    QRegularExpression spacePattern(R"(\s+(\d+(?:\.\d+)*))");
    QRegularExpressionMatch spaceMatch = spacePattern.match(banner);
    if (spaceMatch.hasMatch()) {
        return spaceMatch.captured(1);
    }

    // Pattern 4: Standalone version number at start or end
    QRegularExpression standalonePattern(R"((?:^|[\s\-])(\d+(?:\.\d+)+)(?:[\s\-]|$))");
    QRegularExpressionMatch standaloneMatch = standalonePattern.match(banner);
    if (standaloneMatch.hasMatch()) {
        return standaloneMatch.captured(1);
    }

    return QString(); // No version found
}

bool VulnerabilityMatcher::matchesVersion(const QString& version, const QString& pattern)
{
    if (pattern.isEmpty() || version.isEmpty()) {
        return false;
    }

    // Handle wildcard pattern (e.g., "1.*" matches "1.0", "1.2.3", etc.)
    if (pattern.contains('*')) {
        QString prefix = pattern.left(pattern.indexOf('*'));
        return version.startsWith(prefix);
    }

    // Handle range pattern (e.g., "2.0-2.5")
    if (pattern.contains('-')) {
        QStringList parts = pattern.split('-');
        if (parts.size() == 2) {
            QString minVersion = parts[0].trimmed();
            QString maxVersion = parts[1].trimmed();

            int cmpMin = compareVersions(version, minVersion);
            int cmpMax = compareVersions(version, maxVersion);

            // Version is in range if: version >= minVersion && version <= maxVersion
            return (cmpMin >= 0 && cmpMax <= 0);
        }
    }

    // Handle exact match
    return (compareVersions(version, pattern) == 0);
}

int VulnerabilityMatcher::compareVersions(const QString& v1, const QString& v2)
{
    QStringList parts1 = v1.split('.');
    QStringList parts2 = v2.split('.');

    int maxLen = qMax(parts1.size(), parts2.size());

    for (int i = 0; i < maxLen; ++i) {
        int num1 = (i < parts1.size()) ? parts1[i].toInt() : 0;
        int num2 = (i < parts2.size()) ? parts2[i].toInt() : 0;

        if (num1 < num2) return -1;
        if (num1 > num2) return 1;
    }

    return 0; // Versions are equal
}
