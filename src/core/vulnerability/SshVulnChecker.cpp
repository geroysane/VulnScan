#include "SshVulnChecker.h"
#include <QEventLoop>
#include <QTimer>
#include <QRegularExpression>

SshVulnChecker::SshVulnChecker(QObject *parent)
    : ServiceVulnChecker(parent)
{
}

SshVulnChecker::~SshVulnChecker()
{
}

bool SshVulnChecker::canHandle(const QString &serviceName) const
{
    QString lower = serviceName.toLower();
    return lower.contains("ssh") || lower.contains("openssh");
}

QString SshVulnChecker::name() const
{
    return "SSH Vulnerability Checker";
}

QString SshVulnChecker::description() const
{
    return "Checks for outdated SSH versions, weak algorithms, weak ciphers, "
           "and banner disclosure issues.";
}

QList<Vulnerability> SshVulnChecker::checkVulnerabilities(const QString &host, const PortResult &port)
{
    QList<Vulnerability> vulnerabilities;

    QString serviceName = QString("%1 %2").arg(port.service, port.version).trimmed();

    // Get SSH banner
    QString banner = getSshBanner(host, port.port);
    if (banner.isEmpty()) {
        emit errorOccurred("Failed to retrieve SSH banner");
        emit checkComplete(vulnerabilities);
        return vulnerabilities;
    }

    // Perform various checks
    vulnerabilities.append(checkSshVersion(banner, serviceName));
    vulnerabilities.append(checkWeakKeyExchange(banner, serviceName));
    vulnerabilities.append(checkWeakCiphers(banner, serviceName));
    vulnerabilities.append(checkBannerDisclosure(banner, serviceName));

    emit checkComplete(vulnerabilities);
    return vulnerabilities;
}

QString SshVulnChecker::getSshBanner(const QString &host, int port)
{
    QTcpSocket socket;
    QString banner;

    socket.connectToHost(host, port);

    QEventLoop loop;
    QTimer timer;
    timer.setSingleShot(true);

    connect(&socket, &QTcpSocket::connected, &loop, &QEventLoop::quit);
    connect(&socket, &QTcpSocket::errorOccurred, &loop, &QEventLoop::quit);
    connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);

    timer.start(m_timeout);
    loop.exec();

    if (!timer.isActive() || socket.state() != QTcpSocket::ConnectedState) {
        return banner;
    }

    timer.stop();

    // Wait for SSH banner
    timer.start(m_timeout);
    connect(&socket, &QTcpSocket::readyRead, &loop, &QEventLoop::quit);
    loop.exec();

    if (socket.bytesAvailable() > 0) {
        banner = QString::fromUtf8(socket.readLine()).trimmed();
    }

    socket.disconnectFromHost();
    return banner;
}

QList<Vulnerability> SshVulnChecker::checkSshVersion(const QString &banner, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Check for SSH-1.x (deprecated and insecure)
    if (banner.contains("SSH-1.", Qt::CaseInsensitive)) {
        Vulnerability vuln = createVulnerability(
            "SSH-PROTOCOL-V1",
            "SSH Protocol version 1.x is enabled. This version has known cryptographic weaknesses "
            "and should not be used.",
            "Critical",
            9.8f,
            serviceName,
            "Disable SSH protocol version 1.x and use only SSH-2.0"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    // Check for old OpenSSH versions with known CVEs
    if (banner.contains("OpenSSH", Qt::CaseInsensitive)) {
        QString version = extractVersion(banner);

        // OpenSSH < 7.4 has multiple CVEs
        if (!version.isEmpty() && compareVersions(version, "7.4") < 0) {
            Vulnerability vuln = createVulnerability(
                "SSH-OUTDATED-VERSION",
                QString("OpenSSH version %1 is outdated and has known security vulnerabilities. "
                       "Multiple CVEs affect versions before 7.4.").arg(version),
                "High",
                7.5f,
                serviceName,
                "Update OpenSSH to version 7.4 or later"
            );
            vulnerabilities.append(vuln);
            emit vulnerabilityDetected(vuln);
        }

        // OpenSSH < 8.3 vulnerable to CVE-2020-15778
        if (!version.isEmpty() && compareVersions(version, "8.3") < 0) {
            Vulnerability vuln = createVulnerability(
                "CVE-2020-15778",
                QString("OpenSSH version %1 is vulnerable to CVE-2020-15778: "
                       "scp allows command injection via backtick characters.").arg(version),
                "High",
                7.8f,
                serviceName,
                "Update OpenSSH to version 8.3 or later"
            );
            vulnerabilities.append(vuln);
            emit vulnerabilityDetected(vuln);
        }
    }

    return vulnerabilities;
}

QList<Vulnerability> SshVulnChecker::checkWeakKeyExchange(const QString &banner, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Note: Full key exchange algorithm detection requires SSH protocol negotiation
    // This is a simplified check based on known issues with older versions

    QString version = extractVersion(banner);
    if (version.isEmpty()) {
        return vulnerabilities;
    }

    // Older versions may support weak DH group1-sha1
    if (compareVersions(version, "7.0") < 0) {
        Vulnerability vuln = createVulnerability(
            "SSH-WEAK-KEX-ALGORITHM",
            "SSH server may support weak key exchange algorithms like diffie-hellman-group1-sha1. "
            "These algorithms use small key sizes and are vulnerable to attacks.",
            "Medium",
            5.9f,
            serviceName,
            "Update SSH server and disable weak key exchange algorithms (group1-sha1, group14-sha1)"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    return vulnerabilities;
}

QList<Vulnerability> SshVulnChecker::checkWeakCiphers(const QString &banner, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    QString version = extractVersion(banner);
    if (version.isEmpty()) {
        return vulnerabilities;
    }

    // Older versions may support weak ciphers
    if (compareVersions(version, "7.0") < 0) {
        Vulnerability vuln = createVulnerability(
            "SSH-WEAK-CIPHER",
            "SSH server may support weak encryption ciphers like 3des-cbc, arcfour, or blowfish. "
            "These ciphers have known weaknesses and should be disabled.",
            "Medium",
            5.3f,
            serviceName,
            "Update SSH server and disable weak ciphers (3des, arcfour, blowfish, rc4)"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    return vulnerabilities;
}

QList<Vulnerability> SshVulnChecker::checkBannerDisclosure(const QString &banner, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Check if banner reveals detailed version information
    QRegularExpression versionPattern("(OpenSSH|Dropbear|libssh)[_\\-]([0-9]+\\.[0-9]+[p0-9]*)");
    QRegularExpressionMatch match = versionPattern.match(banner);

    if (match.hasMatch()) {
        Vulnerability vuln = createVulnerability(
            "SSH-BANNER-DISCLOSURE",
            QString("SSH banner reveals detailed version information: '%1'. "
                   "This helps attackers identify known vulnerabilities in specific versions.").arg(banner),
            "Low",
            2.7f,
            serviceName,
            "Configure SSH server to hide detailed version information in banner"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    return vulnerabilities;
}

QString SshVulnChecker::extractVersion(const QString &banner) const
{
    // Extract version from banner like "SSH-2.0-OpenSSH_7.4p1"
    QRegularExpression versionPattern("(OpenSSH|Dropbear|libssh)[_\\-]([0-9]+\\.[0-9]+)([p0-9]*)");
    QRegularExpressionMatch match = versionPattern.match(banner);

    if (match.hasMatch()) {
        return match.captured(2); // Return just the version number (e.g., "7.4")
    }

    return QString();
}

int SshVulnChecker::compareVersions(const QString &version1, const QString &version2) const
{
    QStringList parts1 = version1.split('.');
    QStringList parts2 = version2.split('.');

    int maxParts = qMax(parts1.size(), parts2.size());

    for (int i = 0; i < maxParts; ++i) {
        int v1 = (i < parts1.size()) ? parts1[i].toInt() : 0;
        int v2 = (i < parts2.size()) ? parts2[i].toInt() : 0;

        if (v1 < v2) return -1;
        if (v1 > v2) return 1;
    }

    return 0;
}
