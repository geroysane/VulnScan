#include "FtpVulnChecker.h"
#include <QEventLoop>
#include <QTimer>
#include <QRegularExpression>

FtpVulnChecker::FtpVulnChecker(QObject *parent)
    : ServiceVulnChecker(parent)
{
}

FtpVulnChecker::~FtpVulnChecker()
{
}

bool FtpVulnChecker::canHandle(const QString &serviceName) const
{
    QString lower = serviceName.toLower();
    return lower.contains("ftp") && !lower.contains("tftp");
}

QString FtpVulnChecker::name() const
{
    return "FTP Vulnerability Checker";
}

QString FtpVulnChecker::description() const
{
    return "Checks for anonymous login, FTP bounce vulnerability, plain-text authentication, "
           "outdated versions, and banner disclosure.";
}

QList<Vulnerability> FtpVulnChecker::checkVulnerabilities(const QString &host, const PortResult &port)
{
    QList<Vulnerability> vulnerabilities;

    QString serviceName = QString("%1 %2").arg(port.service, port.version).trimmed();

    // Get FTP banner
    QString banner;
    if (!connectAndGetBanner(host, port.port, banner)) {
        emit errorOccurred("Failed to connect to FTP server");
        emit checkComplete(vulnerabilities);
        return vulnerabilities;
    }

    // Perform various checks
    vulnerabilities.append(checkAnonymousLogin(host, port.port, serviceName));
    vulnerabilities.append(checkPlainTextAuth(port.port, serviceName));
    vulnerabilities.append(checkFtpVersion(banner, serviceName));
    vulnerabilities.append(checkBannerDisclosure(banner, serviceName));
    vulnerabilities.append(checkFtpBounce(host, port.port, serviceName));

    emit checkComplete(vulnerabilities);
    return vulnerabilities;
}

bool FtpVulnChecker::connectAndGetBanner(const QString &host, int port, QString &banner)
{
    QTcpSocket socket;
    socket.connectToHost(host, port);

    QEventLoop loop;
    QTimer timer;
    timer.setSingleShot(true);

    connect(&socket, &QTcpSocket::connected, &loop, &QEventLoop::quit);
    connect(&socket, &QTcpSocket::errorOccurred, &loop, &QEventLoop::quit);
    connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);

    timer.start(m_timeout);
    loop.exec();

    if (!timer.isActive() || socket.state() != QTcpSocket::ConnectedState) {
        return false;
    }

    timer.stop();

    // Wait for FTP banner (220 response)
    timer.start(m_timeout);
    connect(&socket, &QTcpSocket::readyRead, &loop, &QEventLoop::quit);
    loop.exec();

    if (socket.bytesAvailable() > 0) {
        banner = QString::fromUtf8(socket.readAll()).trimmed();
    }

    socket.disconnectFromHost();
    return !banner.isEmpty();
}

QString FtpVulnChecker::sendCommand(QTcpSocket *socket, const QString &command)
{
    if (!socket || socket->state() != QTcpSocket::ConnectedState) {
        return QString();
    }

    socket->write((command + "\r\n").toUtf8());
    socket->flush();

    QEventLoop loop;
    QTimer timer;
    timer.setSingleShot(true);

    connect(socket, &QTcpSocket::readyRead, &loop, &QEventLoop::quit);
    connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);

    timer.start(m_timeout);
    loop.exec();

    if (socket->bytesAvailable() > 0) {
        return QString::fromUtf8(socket->readAll()).trimmed();
    }

    return QString();
}

QList<Vulnerability> FtpVulnChecker::checkAnonymousLogin(const QString &host, int port, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    QTcpSocket socket;
    socket.connectToHost(host, port);

    QEventLoop loop;
    QTimer timer;
    timer.setSingleShot(true);

    connect(&socket, &QTcpSocket::connected, &loop, &QEventLoop::quit);
    connect(&socket, &QTcpSocket::errorOccurred, &loop, &QEventLoop::quit);
    connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);

    timer.start(m_timeout);
    loop.exec();

    if (!timer.isActive() || socket.state() != QTcpSocket::ConnectedState) {
        return vulnerabilities;
    }

    timer.stop();

    // Wait for banner
    timer.start(m_timeout);
    connect(&socket, &QTcpSocket::readyRead, &loop, &QEventLoop::quit);
    loop.exec();

    if (socket.bytesAvailable() > 0) {
        socket.readAll(); // Consume banner
    }

    // Try anonymous login
    QString userResponse = sendCommand(&socket, "USER anonymous");
    if (userResponse.startsWith("331")) { // User name okay, need password
        QString passResponse = sendCommand(&socket, "PASS anonymous@");

        if (passResponse.startsWith("230")) { // User logged in
            Vulnerability vuln = createVulnerability(
                "FTP-ANONYMOUS-LOGIN",
                "FTP server allows anonymous login. This may expose sensitive files to unauthorized users.",
                "High",
                7.5f,
                serviceName,
                "Disable anonymous FTP access or restrict it to a safe, isolated directory"
            );
            vulnerabilities.append(vuln);
            emit vulnerabilityDetected(vuln);

            sendCommand(&socket, "QUIT");
        }
    }

    socket.disconnectFromHost();
    return vulnerabilities;
}

QList<Vulnerability> FtpVulnChecker::checkPlainTextAuth(int port, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Check if it's not FTPS (port 990) or implicit SSL
    if (port != 990) {
        Vulnerability vuln = createVulnerability(
            "FTP-PLAIN-TEXT-AUTH",
            "FTP server uses plain-text authentication. Credentials and data are transmitted "
            "in clear text and can be intercepted by attackers.",
            "High",
            7.5f,
            serviceName,
            "Use FTPS (FTP over SSL/TLS) or SFTP (SSH File Transfer Protocol) instead of plain FTP"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    return vulnerabilities;
}

QList<Vulnerability> FtpVulnChecker::checkFtpVersion(const QString &banner, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Check for ProFTPD < 1.3.5 (CVE-2015-3306)
    if (banner.contains("ProFTPD", Qt::CaseInsensitive)) {
        QString version = extractVersion(banner);
        if (!version.isEmpty()) {
            QStringList parts = version.split('.');
            if (parts.size() >= 3) {
                int major = parts[0].toInt();
                int minor = parts[1].toInt();
                int patch = parts[2].toInt();

                if (major < 1 || (major == 1 && minor < 3) || (major == 1 && minor == 3 && patch < 5)) {
                    Vulnerability vuln = createVulnerability(
                        "CVE-2015-3306",
                        QString("ProFTPD version %1 is vulnerable to CVE-2015-3306: "
                               "mod_copy module allows remote code execution.").arg(version),
                        "Critical",
                        9.8f,
                        serviceName,
                        "Update ProFTPD to version 1.3.5 or later"
                    );
                    vulnerabilities.append(vuln);
                    emit vulnerabilityDetected(vuln);
                }
            }
        }
    }

    // Check for vsftpd < 3.0.3 (CVE-2015-1419)
    if (banner.contains("vsftpd", Qt::CaseInsensitive)) {
        QString version = extractVersion(banner);
        if (!version.isEmpty()) {
            QStringList parts = version.split('.');
            if (parts.size() >= 3) {
                int major = parts[0].toInt();
                int minor = parts[1].toInt();
                int patch = parts[2].toInt();

                if (major < 3 || (major == 3 && minor == 0 && patch < 3)) {
                    Vulnerability vuln = createVulnerability(
                        "CVE-2015-1419",
                        QString("vsftpd version %1 is vulnerable to CVE-2015-1419: "
                               "config file allows remote denial of service.").arg(version),
                        "Medium",
                        5.3f,
                        serviceName,
                        "Update vsftpd to version 3.0.3 or later"
                    );
                    vulnerabilities.append(vuln);
                    emit vulnerabilityDetected(vuln);
                }
            }
        }
    }

    return vulnerabilities;
}

QList<Vulnerability> FtpVulnChecker::checkBannerDisclosure(const QString &banner, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    // Check if banner reveals detailed version information
    QRegularExpression versionPattern("(ProFTPD|vsftpd|Pure-FTPd|FileZilla)[\\s/]([0-9]+\\.[0-9]+\\.[0-9]+)");
    QRegularExpressionMatch match = versionPattern.match(banner);

    if (match.hasMatch()) {
        Vulnerability vuln = createVulnerability(
            "FTP-BANNER-DISCLOSURE",
            QString("FTP banner reveals detailed version information: '%1'. "
                   "This helps attackers identify known vulnerabilities in specific versions.").arg(banner),
            "Low",
            2.7f,
            serviceName,
            "Configure FTP server to hide detailed version information in banner"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    return vulnerabilities;
}

QList<Vulnerability> FtpVulnChecker::checkFtpBounce(const QString &host, int port, const QString &serviceName)
{
    QList<Vulnerability> vulnerabilities;

    QTcpSocket socket;
    socket.connectToHost(host, port);

    QEventLoop loop;
    QTimer timer;
    timer.setSingleShot(true);

    connect(&socket, &QTcpSocket::connected, &loop, &QEventLoop::quit);
    connect(&socket, &QTcpSocket::errorOccurred, &loop, &QEventLoop::quit);
    connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);

    timer.start(m_timeout);
    loop.exec();

    if (!timer.isActive() || socket.state() != QTcpSocket::ConnectedState) {
        return vulnerabilities;
    }

    timer.stop();

    // Wait for banner
    timer.start(m_timeout);
    connect(&socket, &QTcpSocket::readyRead, &loop, &QEventLoop::quit);
    loop.exec();

    if (socket.bytesAvailable() > 0) {
        socket.readAll(); // Consume banner
    }

    // Try anonymous login first
    QString userResponse = sendCommand(&socket, "USER anonymous");
    if (userResponse.startsWith("331")) {
        sendCommand(&socket, "PASS anonymous@");
    }

    // Try PORT command to external address (bounce attack test)
    // PORT command format: PORT h1,h2,h3,h4,p1,p2
    // Using example.com IP (93.184.216.34) and port 80 (0,80)
    QString portResponse = sendCommand(&socket, "PORT 93,184,216,34,0,80");

    if (portResponse.startsWith("200")) { // PORT command accepted
        Vulnerability vuln = createVulnerability(
            "FTP-BOUNCE-ATTACK",
            "FTP server is vulnerable to FTP bounce attack (PORT command to arbitrary hosts). "
            "This allows attackers to use the FTP server as a proxy to scan or attack other systems.",
            "High",
            7.5f,
            serviceName,
            "Configure FTP server to reject PORT commands to external IP addresses"
        );
        vulnerabilities.append(vuln);
        emit vulnerabilityDetected(vuln);
    }

    sendCommand(&socket, "QUIT");
    socket.disconnectFromHost();

    return vulnerabilities;
}

QString FtpVulnChecker::extractVersion(const QString &banner) const
{
    // Extract version from banner like "220 ProFTPD 1.3.5 Server"
    QRegularExpression versionPattern("(ProFTPD|vsftpd|Pure-FTPd|FileZilla)[\\s/]([0-9]+\\.[0-9]+\\.[0-9]+)");
    QRegularExpressionMatch match = versionPattern.match(banner);

    if (match.hasMatch()) {
        return match.captured(2); // Return version number
    }

    return QString();
}
